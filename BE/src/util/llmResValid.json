{
    "id": "msg_017GXMK5Tk5uoRFtCpmmyyxW",
    "type": "message",
    "role": "assistant",
    "model": "claude-3-7-sonnet-20250219",
    "content": [
      {
        "type": "text",
        "text": "from manim import *\nimport math\n\nclass BinarySearch(Scene):\n    def construct(self):\n        # Set up the technical specifications\n        config.pixel_height = 720\n        config.pixel_width = 1280\n        config.frame_rate = 24\n        \n        # Create title\n        title = Text(\"Binary Search Algorithm\", font_size=48)\n        title.to_edge(UP, buff=0.5)\n        self.play(Write(title), run_time=1)\n        \n        # Create array\n        array_size = 10\n        array_values = [i * 10 for i in range(1, array_size + 1)]\n        \n        # Create array squares\n        squares = VGroup(*[\n            Square(side_length=0.8).set_stroke(WHITE, 2)\n            for _ in range(array_size)\n        ]).arrange(RIGHT, buff=0.1)\n        squares.next_to(title, DOWN, buff=1)\n        \n        # Add array values\n        values = VGroup(*[\n            Text(str(val), font_size=24)\n            for val in array_values\n        ])\n        \n        # Position values inside squares\n        for value, square in zip(values, squares):\n            value.move_to(square.get_center())\n        \n        # Create array with values\n        array = VGroup(squares, values)\n        \n        # Create array indices\n        indices = VGroup(*[\n            Text(str(i), font_size=20)\n            for i in range(array_size)\n        ])\n        \n        # Position indices below squares\n        for index, square in zip(indices, squares):\n            index.next_to(square, DOWN, buff=0.3)\n        \n        # Show array\n        self.play(Create(squares), run_time=1)\n        self.play(Write(values), run_time=1)\n        self.play(Write(indices), run_time=1)\n        self.wait(0.5)\n        \n        # Explanation text\n        explanation = Text(\"Binary Search finds a value in a sorted array\\nby repeatedly dividing the search space in half\", \n                          font_size=28)\n        explanation.next_to(squares, DOWN, buff=1.5)\n        \n        self.play(Write(explanation), run_time=1.5)\n        self.wait(1)\n        \n        # Replace explanation with steps\n        steps = BulletedList(\n            \"Start with the entire sorted array\",\n            \"Compare the target with the middle element\",\n            \"If equal, we've found it!\",\n            \"If target < middle, search the left half\",\n            \"If target > middle, search the right half\",\n            \"Repeat until found or subarray is empty\",\n            font_size=24\n        )\n        steps.next_to(squares, DOWN, buff=1.5)\n        \n        self.play(FadeOut(explanation), FadeIn(steps), run_time=1)\n        self.wait(1)\n        \n        # Target value\n        target_value = 50\n        target_text = Text(f\"Target: {target_value}\", font_size=36)\n        target_text.to_edge(LEFT, buff=0.5)\n        target_text.shift(UP * 0.5)\n        \n        self.play(Write(target_text), run_time=0.8)\n        self.wait(0.5)\n        \n        # Binary search visualization\n        left_arrow = Arrow(start=DOWN, end=UP, color=BLUE).scale(0.5)\n        right_arrow = Arrow(start=DOWN, end=UP, color=BLUE).scale(0.5)\n        mid_arrow = Arrow(start=DOWN, end=UP, color=GREEN).scale(0.7)\n        \n        # Highlight step 1\n        self.play(steps[0].animate.set_color(YELLOW), run_time=0.5)\n        \n        # Initialize pointers\n        left, right = 0, array_size - 1\n        \n        # Position left and right arrows\n        left_arrow.next_to(squares[left], UP, buff=0.3)\n        right_arrow.next_to(squares[right], UP, buff=0.3)\n        \n        # Show left and right pointers\n        left_label = Text(\"L\", font_size=20, color=BLUE).next_to(left_arrow, UP, buff=0.1)\n        right_label = Text(\"R\", font_size=20, color=BLUE).next_to(right_arrow, UP, buff=0.1)\n        \n        self.play(\n            Create(left_arrow),\n            Create(right_arrow),\n            Write(left_label),\n            Write(right_label),\n            run_time=0.8\n        )\n        self.wait(0.5)\n        \n        # Binary search iterations\n        found = False\n        iteration = 1\n        \n        # Continue until search completes\n        while left <= right and not found and iteration <= 3:  # Limit iterations for animation\n            # Highlight step 2\n            self.play(\n                steps[0].animate.set_color(WHITE),\n                steps[1].animate.set_color(YELLOW),\n                run_time=0.5\n            )\n            \n            # Calculate middle index\n            mid = (left + right) // 2\n            \n            # Position middle arrow\n            mid_arrow.next_to(squares[mid], UP, buff=0.3)\n            mid_label = Text(\"M\", font_size=20, color=GREEN).next_to(mid_arrow, UP, buff=0.1)\n            \n            # Show middle pointer\n            self.play(\n                Create(mid_arrow),\n                Write(mid_label),\n                run_time=0.8\n            )\n            \n            # Highlight mid value\n            mid_highlight = squares[mid].copy().set_fill(YELLOW, opacity=0.3)\n            self.play(FadeIn(mid_highlight), run_time=0.5)\n            \n            # Compare with target\n            if array_values[mid] == target_value:\n                # Highlight step 3\n                self.play(\n                    steps[1].animate.set_color(WHITE),\n                    steps[2].animate.set_color(GREEN),\n                    run_time=0.5\n                )\n                \n                # Found message\n                found_text = Text(\"Target Found!\", font_size=36, color=GREEN)\n                found_text.next_to(target_text, DOWN, buff=0.5)\n                \n                self.play(\n                    squares[mid].animate.set_fill(GREEN, opacity=0.5),\n                    FadeOut(mid_highlight),\n                    Write(found_text),\n                    run_time=1\n                )\n                found = True\n                \n            elif array_values[mid] < target_value:\n                # Highlight step 5\n                self.play(\n                    steps[1].animate.set_color(WHITE),\n                    steps[4].animate.set_color(YELLOW),\n                    run_time=0.5\n                )\n                \n                # Target > mid, search right half\n                comparison = Text(f\"{array_values[mid]} < {target_value}\", font_size=28)\n                comparison.next_to(mid_label, UP, buff=0.3)\n                \n                self.play(Write(comparison), run_time=0.8)\n                self.wait(0.5)\n                \n                # Gray out left half\n                left_half = VGroup(*[squares[i].copy().set_fill(GRAY, opacity=0.5) \n                                   for i in range(left, mid + 1)])\n                \n                self.play(\n                    FadeIn(left_half),\n                    FadeOut(comparison),\n                    FadeOut(mid_highlight),\n                    run_time=0.8\n                )\n                \n                # Update left pointer\n                left = mid + 1\n                new_left_arrow = Arrow(start=DOWN, end=UP, color=BLUE).scale(0.5)\n                new_left_label = Text(\"L\", font_size=20, color=BLUE)\n                \n                if left <= right:\n                    new_left_arrow.next_to(squares[left], UP, buff=0.3)\n                    new_left_label.next_to(new_left_arrow, UP, buff=0.1)\n                    \n                    self.play(\n                        FadeOut(left_arrow),\n                        FadeOut(left_label),\n                        FadeOut(mid_arrow),\n                        FadeOut(mid_label),\n                        Create(new_left_arrow),\n                        Write(new_left_label),\n                        run_time=0.8\n                    )\n                    \n                    left_arrow = new_left_arrow\n                    left_label = new_left_label\n                \n            else:\n                # Highlight step 4\n                self.play(\n                    steps[1].animate.set_color(WHITE),\n                    steps[3].animate.set_color(YELLOW),\n                    run_time=0.5\n                )\n                \n                # Target < mid, search left half\n                comparison = Text(f\"{array_values[mid]} > {target_value}\", font_size=28)\n                comparison.next_to(mid_label, UP, buff=0.3)\n                \n                self.play(Write(comparison), run_time=0.8)\n                self.wait(0.5)\n                \n                # Gray out right half\n                right_half = VGroup(*[squares[i].copy().set_fill(GRAY, opacity=0.5) \n                                    for i in range(mid, right + 1)])\n                \n                self.play(\n                    FadeIn(right_half),\n                    FadeOut(comparison),\n                    FadeOut(mid_highlight),\n                    run_time=0.8\n                )\n                \n                # Update right pointer\n                right = mid - 1\n                new_right_arrow = Arrow(start=DOWN, end=UP, color=BLUE).scale(0.5)\n                new_right_label = Text(\"R\", font_size=20, color=BLUE)\n                \n                if left <= right:\n                    new_right_arrow.next_to(squares[right], UP, buff=0.3)\n                    new_right_label.next_to(new_right_arrow, UP, buff=0.1)\n                    \n                    self.play(\n                        FadeOut(right_arrow),\n                        FadeOut(right_label),\n                        FadeOut(mid_arrow),\n                        FadeOut(mid_label),\n                        Create(new_right_arrow),\n                        Write(new_right_label),\n                        run_time=0.8\n                    )\n                    \n                    right_arrow = new_right_arrow\n                    right_label = new_right_label\n            \n            # Increment iteration counter\n            iteration += 1\n            \n            # Highlight step 6 and pause between iterations\n            if not found and left <= right:\n                self.play(\n                    steps[3].animate.set_color(WHITE) if array_values[mid] > target_value else steps[4].animate.set_color(WHITE),\n                    steps[5].animate.set_color(YELLOW),\n                    run_time=0.5\n                )\n                self.wait(0.5)\n        \n        # Show time complexity\n        complexity = MathTex(r\"\\text{Time Complexity: } O(\\log n)\", font_size=36)\n        complexity.to_edge(DOWN, buff=0.5\n        \n        self.play(Write(complexity), run_time=1)\n        self.wait(1)\n"
      }
    ],
    "stop_reason": "end_turn",
    "stop_sequence": null,
    "usage": {
      "input_tokens": 921,
      "cache_creation_input_tokens": 0,
      "cache_read_input_tokens": 0,
      "output_tokens": 2893
    },
    "_request_id": "req_011CP5yL3cBbfTix7yWdjZqD"
  }